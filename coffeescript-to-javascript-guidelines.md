# CoffeeScript to JavaScript Guidelines

## Steps
1. Rename your file extension from `foo.coffee` to `foo.js`
2. Open http://js2.coffee/ & paste the entire contents `foo.js` into the CoffeeScript side
3. Paste the entire contents of the output back into your `foo.js`
4. Rebuild the app, functionality should be unchanged & there should be no JS errors in the console
5. Refactor the “CoffeeScript magic”, using [examples below](#refactoring-coffeescript-magic)
6. If this conversion is being done at the same time as a feature, submit a PR using the [interstitial PR process](#interstitial-pr-process)

## Refactoring CoffeeScript magic

_**Disclaimer**: This file is not a JavaScript style guide. Reference the following files for coding style & principles:_
* [General Javascript Best Practices](/general-javascript-best-practices.md)
* [Clientside Javascript (Backbone) Best Practices](/clientside-javascript-best-practices.md)
* [Coding Principles](/coding-principles.md)

### Classes & super
#### CoffeeScript

```coffee
class CoreProduct extends Product

  initialize: ->
    super
```

#### Generated JavaScript
This is what would be output from js2coffee

```javascript
var CoreProduct,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CoreProduct = (function(superClass) {
  extend(CoreProduct, superClass);

  function CoreProduct() {
    return CoreProduct.__super__.constructor.apply(this, arguments);
  }

  CoreProduct.prototype.initialize = function() {
    return CoreProduct.__super__.initialize.apply(this, arguments);
  };

  return CoreProduct;

})(Product);

// ---
// generated by coffee-script 1.9.2
```

#### Refactored JavaScript
We can change from CoffeeScript's classes to Backbone's classes, like so

```javascript
var CoreProduct = Product.extend({
  initialize: function() {
    // we also change from using from `CoreProduct.__super__` to `Product.prototype`
    return Product.prototype.initialize.apply(this, arguments);
  }
});
```

### Variables
#### CoffeeScript

```coffee
_ = require('underscore')
Product = require('models/product')
TerminalMixins = require('presenters/mixins/terminal')
```

#### Generated JavaScript
This is what would be output from js2coffee

```javascript
var Product, TerminalMixins, _;

_ = require('underscore');

Product = require('models/product');

TerminalMixins = require('presenters/mixins/terminal');

// ---
// generated by coffee-script 1.9.2
```

#### Refactored JavaScript
We would move the variable declarations to the same line that they are initialised, like so

```javascript
var _ = require('underscore');
var Product = require('models/product');
var TerminalMixins = require('presenters/mixins/terminal');
```

### Existence checks
#### CoffeeScript

```coffee
_hasFlightCode: ->
  @get('flights')?.out?.flight?.code
```

#### Generated JavaScript
This is what would be output from js2coffee

```javascript
_hasFlightCode: function() {
  var ref, ref1, ref2;
  return (ref = this.get('flights')) != null ? (ref1 = ref.out) != null ? (ref2 = ref1.flight) != null ? ref2.code : void 0 : void 0 : void 0;
}

// ---
// generated by coffee-script 1.9.2
```

#### Refactored JavaScript
This is fairly unreadable, we would remove the temporary `ref` variables and do the following.

```javascript
_hasFlightCode: function() {
  var flights = this.get('flights');
  if(!flights || !flights.out || !flights.out.flight || !flights.out.flight.code)) {
    return;
  }
  return flights.out.flight.code;
}
```

_**Note**: this particular example is excessively complicated. Ideally, if we're having to check a property that's nested this deeply then the checks should be pushed further upstream, such as a flight model in this case._

### Return values
#### CoffeeScript

```coffee
func = ->
  doSomething()
```

#### Generated JavaScript
This is what would be output after the conversion:

```javascript
var func;

func = function() {
  return doSomething();
};
```

#### Refactoring process
With coffeescript the last statement of a function is always returned even if not required.

The first thing to do here is to check how this function is called. It could be called from many places so it's best to perform a search of the code base for the method name.

If the callers expect a return value from the function please keep the `return` keyword, if not please remove it to avoid confusion.

### Full conversion example of `models/carpark.coffee`
https://gist.github.com/jackdcrawford/a8e5dacf6cecdb9b6bfe

## Interstitial PR process
The process for converting CoffeeScript to JavaScript at the same time as writing features

1. Create a new “interstitial” branch, based on the project’s master branch
2. Create a “code conversion” branch, based on the “interstitial” branch
3. Create a “feature” branch, based on the “code conversion branch”
4. Both “code conversion” and “feature” can then be merged into “interstitial”, removing the need for two pull requests to be tested

![Interstitial PR process](https://cloud.githubusercontent.com/assets/1485654/7913291/a1fece40-0866-11e5-84b5-1698ecae101a.png)
